# 斐波拉契数列

斐波拉契数列是这样一种数列，它前两位固定为1，从第3位开始，每一位的值是它之前两位之和

例如：$1, 1, 2, 3, 5, 8, 13, 21, ...$

编写函数，求斐波拉契数列第`n`为的值

```js
function fibonaccf(n){
  // code here
}
```

<img src="http://mdrs.yuanjin.tech/img/20210221143107.png" alt="image-20210221143107148" style="zoom: 33%;" />

# 动态规划

很多求「最优解」的问题都可以考虑使用动态规划解决

动态规划包含两个核心思想：

1. 状态转移方程

   是指把一个大的问题分解为多个重叠子问题，寻找重叠子问题之间的关系

   比如斐波拉契数列的状态转移方程如下：

   ----

   $如果 f(n) 表示斐波拉契数列第 n 位的值$

   $则有：f(n) = f(n - 1) + f(n - 2)$

   -----

   在使用动态规划时，最困难的就是找到状态转移方程

2. dp缓存表

   在求解的过程中，可能会遇到对相同的参数多次求解，为避免重复运算，可以使用缓存表将其解值缓存下来

# 0-1背包问题

有一个背包，容积为`c`

给定一个物品列表：`[o1, o2, o3, o4, ...]`，每个物品有两个属性，分别是价值和体积，例如`{ v:10, p: 5 }`

问: 应如何选择装入背包的物品，使得装入背包中物品的总价值最大？

函数规格：

```js
/**
 * 获取0-1背包问题的最优解
 * @param {Number} c 背包体积
 * @param {{v:Number, p:Number}[]} list 物品列表
 * @returns {Number} 返回最大价值
 */
function package(c, list) {
  // code here
}

// test
var list = [
  { v: 10, p: 5 },
  { v: 7, p: 4 },
  { v: 11, p: 8 },
  { v: 9, p: 6 },
  { v: 2, p: 1 },
  { v: 17, p: 20 },
  { v: 25, p: 30 },
];
var c = 40;
var result = package(c, list);
console.log(result); // expect: 39
```



> 状态转移方程如下：
>
> $设物品空间为 [v_0, v_1, v_2, v_3, ... , v_i]$
>
> $设物品价值为 [p_0, p_1, p_2, p_3, ... , p_i]$
>
> $如果 f(i, rest) 表示从列表第 i 项开始，剩余空间为 rest 的最优解，则状态转移方程为：$
>
> $f(i, rest) = max(p_0 + f(i + 1, rest - v_0), f(i + 1, rest))$